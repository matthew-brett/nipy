<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Neuroimaging in Python &mdash; NIPY Documentation</title>
    
    <link rel="stylesheet" href="../_static/nipy.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.4.0.dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="NIPY Documentation" href="../index.html" />
  <meta name="keywords" content="nipy, neuroimaging, python, neuroscience, time
				 series">

  </head>
  <body role="document">
<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
 <a href="../index.html">
  <img src="../_static/reggie2.png" alt="NIPY logo"  border="0" />
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
  <li><a href="../index.html">NIPY home</a> |&nbsp;</li>
 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">

  
<h4> Site Navigation </h4>
  <ul>
    <li><a href="../documentation.html">Documentation</a></li>
    <li><a href="../devel/index.html">Development</a></li>
  </ul>

<h4> NIPY Community </h4>
  <ul class="simple">
    <li><a class="reference external"
	href="http://nipy.org/">Community Home</a></li>
    <li><a class="reference external"
	href="http://nipy.org/software/projects/">NIPY Projects</a></li>
    <li><a class="reference external"
	href="http://mail.scipy.org/mailman/listinfo/nipy-devel">Mailing List</a></li>
    <li><a class="reference external"
	href="http://nipy.org/software/license/index.html">License</a></li>
  </ul>

<h4> Github repo </h4>
  <ul class="simple">
    <li><a class="reference external"
	href="http://github.com/nipy/nipy/">Nipy Github</a></li>
  </ul>

  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Mathematical formulation of the Coordinate Map</a><ul>
<li><a class="reference internal" href="#manipulating-mappings-coordinate-systems-and-coordinate-maps">Manipulating mappings, coordinate systems and coordinate maps</a><ul>
<li><a class="reference internal" href="#coordinate-systems">Coordinate systems</a></li>
<li><a class="reference internal" href="#mappings">Mappings</a></li>
<li><a class="reference internal" href="#affine-mappings">Affine mappings</a></li>
<li><a class="reference internal" href="#dimensional-affine-mappings">3-dimensional affine mappings</a></li>
<li><a class="reference internal" href="#coordinate-maps">Coordinate maps</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation">Implementation</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/users/math_coordmap.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>

<div id="searchbox-ml" style="display: none">
  <h3>Search mailing list archive</h3>
  <script type="text/javascript">
    function mlsearch(curobj)
    {
    curobj.q.value="site:http://mail.scipy.org/pipermail/nipy-devel/ "+curobj.userquery.value
    }
  </script>
  <form action="http://www.google.com/search" method="get" onSubmit="mlsearch(this)">
    <input name="userquery" size="13" type="text" /> <input type="submit" value="Go" />
    <input name="q" type="hidden" />
  </form>
</div>
  
<div id="searchbox-site" style="display: none">
  <h3>Search this site</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" size="13" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    </p>
</div>
<script type="text/javascript">$('#searchbox-ml').show(0);</script>
<script type="text/javascript">$('#searchbox-site').show(0);</script>


        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="mathematical-formulation-of-the-coordinate-map">
<span id="math-coordmap"></span><h1>Mathematical formulation of the Coordinate Map<a class="headerlink" href="#mathematical-formulation-of-the-coordinate-map" title="Permalink to this headline">Â¶</a></h1>
<p>Using the <em>CoordinateMap</em> can be a little hard to get used to.  For some users,
a mathematical description, free of any python syntax and code design and
snippets may be helpful. After following through this description, the code
design and usage may be clearer.</p>
<p>We return to the normalization example in <a class="reference internal" href="coordinate_map.html#normalize-coordmap"><span>Use of the Coordinate Map for spatial normalization</span></a> and try to
write it out mathematically.  Conceptually, to do normalization, we need to be
able to answer each of these three questions:</p>
<ol class="arabic simple">
<li><em>Voxel-to-world (subject)</em> Given the subjects&#8217; anatomical image read off the
scanner: which physical location, expressed in <span class="math">\((x_s,y_s,z_s)\)</span>
coordinates (<span class="math">\(s\)</span> for subject), corresponds to the voxel of data
<span class="math">\((i_s,j_s,k_s)\)</span>?  This question is answered by <em>subject_im.coordmap</em>.
The actual function that computes this, i.e that takes 3 floats and returns 3
floats, is <em>subject_im.coordmap.mapping</em>.</li>
<li><em>World-to-world (subject to Tailarach)</em> Given a location
<span class="math">\((x_s,y_s,z_s)\)</span> in an anatomical image of the subject, where does it
lie in the Tailarach coordinates <span class="math">\((x_a,y_a, z_a)\)</span>? This is answered by
the matrix <em>T</em> and knowing that <em>T</em> maps a point in the subject&#8217;s world to
Tailarach world. Hence, this question is answered by
<em>subject_world_to_tailarach_world</em> above.</li>
<li><em>Voxel-to-world (Tailarach)</em> Since we want to produce a resampled Image that
has the same shape and coordinate information as <em>atlas_im</em>, we need to know
what location in Tailarach space, <span class="math">\((x_a,y_a,z_a)\)</span> (<span class="math">\(a\)</span> for atlas)
corresponds to the voxel <span class="math">\((i_a,j_a,k_a)\)</span>. This question is answered by
<em>tailarach_cmap</em>.</li>
</ol>
<p>Each of these three questions are answered by, in code, what we called a class
called <em>CoordinateMap</em>.  Mathematically, let&#8217;s define a <em>mapping</em> as a tuple
<span class="math">\((D,R,f)\)</span> where <span class="math">\(D\)</span> is the <em>domain</em>, <span class="math">\(R\)</span> is the <em>range</em> and
<span class="math">\(f:D\rightarrow R\)</span> is a function. It may seem redundant to pair
<span class="math">\((D,R)\)</span> with <span class="math">\(f\)</span> because a function must surely know its domain and
hence, implicitly, its range.  However, we will see that when it comes time to
implement the notion of <em>mapping</em>, the tuple we do use to construct
<em>CoordinateMap</em> is almost, but not quite <span class="math">\((D,R,f)\)</span> and, in the tuple we
use, <span class="math">\(D\)</span> and <span class="math">\(R\)</span> are not reduntant.</p>
<p>Since these mappings are going to be used and called with modules like
<code class="xref py py-mod docutils literal"><span class="pre">numpy</span></code>, we should restrict our definition a little bit. We assume the
following:</p>
<ol class="arabic simple">
<li><span class="math">\(D\)</span> is isomorphic to one of <span class="math">\(\mathbb{Z}^n, \mathbb{R}^n,
\mathbb{C}^n\)</span> for some <span class="math">\(n\)</span>. This isomorphism is determined by a basis
<span class="math">\([u_1,\dots,u_n]\)</span> of <span class="math">\(D\)</span> which maps <span class="math">\(u_i\)</span> to <span class="math">\(e_i\)</span>
the canonical i-th coordinate vector of whichever of <span class="math">\(\mathbb{Z}^n,
\mathbb{R}^n, \mathbb{C}^n\)</span>. This isomorphism is denoted by <span class="math">\(I_D\)</span>.
Strictly speaking, if <span class="math">\(D\)</span> is isomorphic to <span class="math">\(\mathbb{Z}^n\)</span> then
the term basis is possibly misleading because <span class="math">\(D\)</span> because it is not a
vector space, but it is a group so we might call the basis a set of
generators instead. In any case, the implication is that whatever properties
the appropriate <span class="math">\(\mathbb{Z},\mathbb{R},\mathbb{C}\)</span>, so <span class="math">\(D\)</span> (and
<span class="math">\(R\)</span>) has as well.</li>
<li><span class="math">\(R\)</span> is similarly isomorphic to one of  <span class="math">\(\mathbb{Z}^m,
\mathbb{R}^m, \mathbb{C}^m\)</span> for some <span class="math">\(m\)</span> with isomorphism <span class="math">\(I_R\)</span>
and basis <span class="math">\([v_1,\dots,v_m]\)</span>.</li>
</ol>
<p>Above, and throughout, the brackets &#8220;[&#8221;,&#8221;]&#8221; represent things interpretable as
python lists, i.e. sequences.</p>
<p>These isomorphisms are just fancy ways of saying that the point
<span class="math">\(x=3,y=4,z=5\)</span> is represented by the 3 real numbers (3,4,5). In this case
the basis is <span class="math">\([x,y,z]\)</span> and for any <span class="math">\(a,b,c \in \mathbb{R}\)</span></p>
<div class="math">
\[I_D(a\cdot x + b \cdot y + c \cdot z) = a \cdot e_1 + b \cdot e_2 + c \cdot e_3\]</div>
<p>We might call the pairs <span class="math">\(([u_1,...,u_n], I_D), ([v_1,...,v_m], I_R)\)</span>
<em>coordinate systems</em>.  Actually, the bases in effect determine the maps
<span class="math">\(I_D,I_R\)</span> as long as we know which of
<span class="math">\(\mathbb{Z},\mathbb{R},\mathbb{C}\)</span> we are talking about so in effect,
<span class="math">\(([u_1,...,u_n], \mathbb{R})\)</span> could be called a <em>coordinate system</em>.  This
is how it is implemented in the code with <span class="math">\([u_1, \dots, u_n]\)</span> being
replaced by a list of strings naming the basis vectors and <span class="math">\(\mathbb{R}\)</span>
replaced by a builtin <code class="xref py py-func docutils literal"><span class="pre">numpy.dtype()</span></code>.</p>
<p>In our normalization example, we therefore have 3 mappings:</p>
<ol class="arabic">
<li><p class="first"><em>Voxel-to-world (subject)</em> In standard notation for functions, we can write</p>
<div class="math">
\[(i_s,j_s,k_s) \overset{f}{\mapsto} (x_s,y_s,z_s).\]</div>
<p>The domain is <span class="math">\(D=[i_s,j_s,k_s]\)</span>, the range is <span class="math">\(R=[x_s,y_s,z_s]\)</span>
and the function is <span class="math">\(f:D \rightarrow R\)</span>.</p>
</li>
<li><p class="first"><em>World-to-world (subject to Tailarach)</em> Again, we can write</p>
<div class="math">
\[(x_s,y_s,z_s) \overset{g}{\mapsto} (x_a,y_a,z_a)\]</div>
<p>The domain is <span class="math">\(D=[x_s,y_s,z_s]\)</span>, the range is <span class="math">\(R=[x_a,y_a,z_a]\)</span>
and the function is <span class="math">\(g:D \rightarrow R\)</span>.</p>
</li>
<li><p class="first"><em>Voxel-to-world (Tailarach)</em> Again, we can write</p>
<div class="math">
\[(i_a,j_a,k_a) \overset{h}{\mapsto} (x_a,y_a, z_a).\]</div>
<p>The domain is <span class="math">\(D=[i_a,j_a,k_a]\)</span>, the range is <span class="math">\(R=[x_a,y_a,z_a]\)</span>
and the function is <span class="math">\(h:D \rightarrow R\)</span>.</p>
</li>
</ol>
<p>Note that each of the functions <span class="math">\(f,g,h\)</span> can be, when we know the necessary
isomorphisms, thought of as functions from <span class="math">\(\mathbb{R}^3\)</span> to itself. In
fact, that is what we are doing when we write</p>
<blockquote>
<div><div class="math">
\[(i_a,j_a,k_a) \overset{h}{\mapsto} (x_a,y_a, z_a)\]</div>
</div></blockquote>
<p>as a function that takes 3 numbers and gives 3 numbers.</p>
<p>Formally, these functions that take 3 numbers and return 3 numbers can be
written as <span class="math">\(\tilde{f}=I_R \circ f \circ I_D^{-1}\)</span>.  When this is
implemented in code, it is actually the functions <span class="math">\(\tilde{f}, \tilde{g},
\tilde{h}\)</span> we specify, rather then <span class="math">\(f,g,h\)</span>. The functions
<span class="math">\(\tilde{f}, \tilde{g}, \tilde{h}\)</span>  have domains and ranges that are just
<span class="math">\(\mathbb{R}^3\)</span>.  We therefore call a <em>coordinate map</em>  a tuple</p>
<div class="math">
\[((u_D, \mathbb{R}), (u_R, \mathbb{R}), I_R \circ f \circ I_D^{-1})\]</div>
<p>where <span class="math">\(u_D, u_R\)</span> are bases for <span class="math">\(D,R\)</span>, respectively.  It is this
object that is implemented in code. There is a simple relationship between
<em>mappings</em> and <em>coordinate maps</em></p>
<div class="math">
\[((u_D, \mathbb{R}), (u_R, \mathbb{R}), \tilde{f}) \leftrightarrow (D, R, f=I_R^{-1} \circ \tilde{f} \circ I_D)\]</div>
<p>Because <span class="math">\(\tilde{f}, \tilde{g}, \tilde{h}\)</span> are just functions from
<span class="math">\(\mathbb{R}^3\)</span> to itself, they can all be composed with one another. But,
from our description of the functions above, we know that only certain
compositions make sense and others do not, such as <span class="math">\(g \circ h\)</span>.
Compositions that do make sense include</p>
<ol class="arabic simple">
<li><span class="math">\(h^{-1} \circ g\)</span> which <span class="math">\((i_a,j_a, k_a)\)</span> voxel corresponds to the
point <span class="math">\((x_s,y_s,z_s)\)</span>?</li>
<li><span class="math">\(g \circ f\)</span> which <span class="math">\((x_a,y_a,z_a)\)</span> corresponds to the voxel
<span class="math">\((i,j,k)\)</span>?</li>
</ol>
<p>The composition that is used in the normalization example is <span class="math">\(w = f^{-1}
\circ g^{-1} \circ h\)</span> which is a function</p>
<div class="math">
\[(i_a, j_a, k_a) \overset{w}{\mapsto} (i_s, j_s, k_s)\]</div>
<p>This function, or more correctly its representation <span class="math">\(\tilde{w}\)</span> that takes
3 floats to 3 floats, is passed directly to
<code class="xref py py-func docutils literal"><span class="pre">scipy.ndimage.map_coordinates()</span></code>.</p>
<div class="section" id="manipulating-mappings-coordinate-systems-and-coordinate-maps">
<h2>Manipulating mappings, coordinate systems and coordinate maps<a class="headerlink" href="#manipulating-mappings-coordinate-systems-and-coordinate-maps" title="Permalink to this headline">Â¶</a></h2>
<p>In order to solve our normalization problem, we will definitely need to compose
functions. We may want to carry out other formal operations as well. Before
describing operations on mappings, we describe the operations you might want to
consider on coordinate systems.</p>
<div class="section" id="coordinate-systems">
<h3>Coordinate systems<a class="headerlink" href="#coordinate-systems" title="Permalink to this headline">Â¶</a></h3>
<ol class="arabic">
<li><p class="first"><em>Reorder</em>: This is just a reordering of the basis, i.e.
<span class="math">\(([u_1,u_2,u_3], \mathbb{R}) \mapsto ([u_2,u_3,u_1], \mathbb{R})\)</span></p>
</li>
<li><p class="first"><em>Product</em>: Topological product of the coordinate systems (with a small
twist). Given two coordinate systems <span class="math">\(([u_1,u_2,u_3], \mathbb{R}),
([v_1, v_2], \mathbb{Z})\)</span> the product is represented as</p>
<div class="math">
\[([u_1,u_2,u_3], \mathbb{R}) \times ([v_1, v_2], \mathbb{Z})  \mapsto ([u_1,u_2,u_3,v_1,v_2], \mathbb{R})`.\]</div>
<p>Note that the resulting coordinate system is real valued whereas one of the
input coordinate systems was integer valued. We can always embed
<span class="math">\(\mathbb{Z}\)</span> into <span class="math">\(\mathbb{R}\)</span>.  If one of them is complex
valued, the resulting coordinate system is complex valued. In the code, this
is handled by attempting to find a safe builtin numpy.dtype for the two (or
more) given coordinate systems.</p>
</li>
</ol>
</div>
<div class="section" id="mappings">
<h3>Mappings<a class="headerlink" href="#mappings" title="Permalink to this headline">Â¶</a></h3>
<ol class="arabic">
<li><p class="first"><em>Inverse</em>: Given a mapping <span class="math">\(M=(D,R,f)\)</span> if the function <span class="math">\(f\)</span> is
invertible, this is just the obvious <span class="math">\(M^{-1}=(R, D, f^{-1})\)</span>.</p>
</li>
<li><p class="first"><em>Composition</em>: Given two mappings, <span class="math">\(M_f=(D_f, R_f, f)\)</span> and
<span class="math">\(M_g=(D_g, R_g, g)\)</span> if <span class="math">\(D_f == R_g\)</span> then the composition is well
defined and the composition of the mappings <span class="math">\([M_f,M_g]\)</span> is just
<span class="math">\((D_g, R_f, f \circ g)\)</span>.</p>
</li>
<li><p class="first"><em>Reorder domain / range</em>: Given a mapping <span class="math">\(M=(D=[i,j,k], R=[x,y,z], f)\)</span>
you might want to specify that we&#8217;ve changed the domain by changing the
ordering of its basis to <span class="math">\([k,i,j]\)</span>. Call the new domain <span class="math">\(D'\)</span>.
This is represented by the composition of the mappings <span class="math">\([M, O]\)</span> where
<span class="math">\(O=(D', D, I_D^{-1} \circ f_O \circ I_{D'})\)</span> and for  <span class="math">\(a,b,c \in
\mathbb{R}\)</span>:</p>
<div class="math">
\[f_O(a,b,c) = (b,c,a).\]</div>
</li>
<li><p class="first"><em>Linearize</em>: Possibly less used, since we know that <span class="math">\(f\)</span> must map one of
<span class="math">\(\mathbb{Z}^n, \mathbb{R}^n, \mathbb{C}^n\)</span> to one of
<span class="math">\(\mathbb{Z}^m, \mathbb{R}^m, \mathbb{C}^m\)</span>, we might be able
differentiate it at a point <span class="math">\(p \in D\)</span>, yielding its 1st order Taylor
approximation</p>
<div class="math">
\[f_p(d) = f(d) + Df_p(d-p)\]</div>
<p>which is  an affine  function, thus
creating an affine mapping <span class="math">\((D, R, f_p)\)</span>. Affine functions
are discussed in more detail below.</p>
</li>
<li><p class="first"><em>Product</em>: Given two mappings <span class="math">\(M_1=(D_1,R_1,f_1), M_2=(D_2, R_2, f_2)\)</span>
we define their product as the mapping <span class="math">\((D_1 + D_2, R_1 + R_2, f_1
\otimes f_2)\)</span> where</p>
<div class="math">
\[(f_1 \otimes f_2)(d_1, d_2) = (f_1(d_1), f_2(d_2)).\]</div>
<p>Above, we have taken the liberty of expressing the product of the coordinate
systems, say, <span class="math">\(D_1=([u_1, \dots, u_n], \mathbb{R}), D_2=([v_1, \dots,
v_m], \mathbb{C})\)</span> as a python addition of lists.</p>
<p>The name <em>product</em> for this operation is not necessarily canonical. If the
two coordinate systems are  vector spaces and the function is linear, then we
might call this map the <em>direct sum</em> because its domain are direct sums of
vector spaces. The term <em>product</em> here refers to the fact that the domain and
range are true topological products.</p>
</li>
</ol>
</div>
<div class="section" id="affine-mappings">
<h3>Affine mappings<a class="headerlink" href="#affine-mappings" title="Permalink to this headline">Â¶</a></h3>
<p>An <em>affine mapping</em> is one in which the function <span class="math">\(f:D \rightarrow R\)</span> is an
affine function. That is, it can be written as <cite>f(d) = Ad + b</cite> for <span class="math">\(d \in
D\)</span> for some <span class="math">\(n_R \times n_D\)</span> matrix <span class="math">\(A\)</span> with entries that are in one
of <span class="math">\(\mathbb{Z}, \mathbb{R}, \mathbb{C}\)</span>.</p>
<p>Strictly speaking, this is a little abuse of notation because <span class="math">\(d\)</span> is a
point in <span class="math">\(D\)</span> not a tuple of real (or integer or complex) numbers. The
matrix <span class="math">\(A\)</span> represents a linear transformation from <span class="math">\(D\)</span> to <span class="math">\(R\)</span>
in a particular choice of bases for <span class="math">\(D\)</span> and <span class="math">\(R\)</span>.</p>
<p>Let us revisit some of the operations on a mapping as applied to <em>affine
mappings</em> which we write as a tuple <span class="math">\(M=(D, R, T)\)</span> with <span class="math">\(T\)</span> the
representation of the <span class="math">\((A,b)\)</span> in homogeneous coordinates.</p>
<ol class="arabic">
<li><p class="first"><em>Inverse</em>: If <span class="math">\(T\)</span> is invertible, this is just the tuple
<span class="math">\(M^{-1}=(R, D, T^{-1})\)</span>.</p>
</li>
<li><p class="first"><em>Composition</em>: The composition of two affine mappings <span class="math">\([(D_2, R_2,
T_2), (D_1,R_1,T_1)]\)</span> is defined whenever <span class="math">\(R_1==D_2\)</span> and is the tuple
<span class="math">\((D_1, R_2, T_2 T_1)\)</span>.</p>
</li>
<li><p class="first"><em>Reorder domain</em>: A reordering of the domain of an affine mapping
<span class="math">\(M=(D, R, T)\)</span> can be represented by a <span class="math">\((n_D+1) \times (n_D+1)\)</span>
permutation matrix <span class="math">\(P\)</span> (in which the last coordinate is unchanged &#8211;
remember we are in homogeneous coordinates). Hence a reordering of <span class="math">\(D\)</span>
to <span class="math">\(D'\)</span> can be represented as <span class="math">\((D', R, TP)\)</span>. Alternatively, it is
the composition of the affine mappings <span class="math">\([M,(\tilde{D}, D, P)]\)</span>.</p>
</li>
<li><p class="first"><em>Reorder range</em>:  A reordering of the range can  be represented by a
<span class="math">\((n_R+1) \times (n_R+1)\)</span> permutation matrix <span class="math">\(\tilde{P}\)</span>.  Hence a
reordering of <span class="math">\(R\)</span> to <span class="math">\(R'\)</span> can be represented as <span class="math">\((D,
\tilde{R}, \tilde{P}T)\)</span>. Alternatively, it is the composition of the affine
mappings <span class="math">\([(R, \tilde{R}, \tilde{P}), M]\)</span>.</p>
</li>
<li><p class="first"><em>Linearize</em>: Because the mapping <span class="math">\(M=(D,R,T)\)</span> is already affine, this
leaves it unchanged.</p>
</li>
<li><p class="first"><em>Product</em>: Given two affine mappings <span class="math">\(M_1=(D_1,R_1,T_1)\)</span> and
<span class="math">\(M_2=(D_2,R_2,T_2)\)</span> the product is the tuple</p>
<div class="math">
\[\begin{split}\left(D_1+D_2,R_1+R_2,
  \begin{pmatrix}
  T_1 &amp; 0 \\
  0 &amp; T_2
  \end{pmatrix} \right).\end{split}\]</div>
</li>
</ol>
</div>
<div class="section" id="dimensional-affine-mappings">
<h3>3-dimensional affine mappings<a class="headerlink" href="#dimensional-affine-mappings" title="Permalink to this headline">Â¶</a></h3>
<p>For an Image, by far the most common mappings associated to it are affine, and
these are usually maps from a real 3-dimensional domain to a real 3-dimensional
range. These can be represented by the ubiquitous <span class="math">\(4 \times 4\)</span> matrix (the
representation of the affine mapping in homogeneous coordinates), along with
choices for the axes, i.e. <span class="math">\([i,j,k]\)</span> and the spatial coordinates, i.e.
<span class="math">\([x,y,z]\)</span>.</p>
<p>We will revisit some of the operations on mappings  as applied specifically to
3-dimensional affine mappings which we write as a tuple <span class="math">\(A=(D, R, T)\)</span>
where <span class="math">\(T\)</span> is an invertible <span class="math">\(4 \times 4\)</span>  transformation matrix with
real entries.</p>
<ol class="arabic simple">
<li><em>Inverse</em>: Because we have assumed that <span class="math">\(T\)</span> is invertible this is just  tuple <span class="math">\((([x,y,z], \mathbb{R}), ([i,j,k], \mathbb{R}), T^{-1})\)</span>.</li>
<li><em>Composition</em>: Given two 3-dimensional affine mappings <span class="math">\(M_1=(D_1,R_1,
T_1), M_2=(D_2,R_2,T_2)\)</span> the composition of <span class="math">\([M_2,M_1]\)</span> yields another
3-dimensional affine mapping whenever <span class="math">\(R_1 == D_2\)</span>. That is, it yields
<span class="math">\((D_1, R_2, T_2T_1)\)</span>.</li>
<li><em>Reorder domain</em> A reordering of the domain can be represented by a <span class="math">\(4
\times 4\)</span> permutation matrix <span class="math">\(P\)</span> (with its last coordinate not
changing). Hence the reordering of <span class="math">\(D=([i,j,k], \mathbb{R})\)</span> to
<span class="math">\(([k,i,j], \mathbb{R})\)</span> can be represented as <span class="math">\((([k,i,j],
\mathbb{R}), R, TP)\)</span>.</li>
<li><em>Reorder range</em>: A reordering of the range can also be represented by a
<span class="math">\(4 \times 4\)</span> permutation matrix <span class="math">\(\tilde{P}\)</span> (with its last
coordinate not changing). Hence the reordering of <span class="math">\(R=([x,y,z],
\mathbb{R})\)</span> to <span class="math">\(([z,x,y], \mathbb{R})\)</span> can be represented as
<span class="math">\((D, ([z,x,y], \mathbb{R}), \tilde{P}, T)\)</span>.</li>
<li><em>Linearize</em>: Just as for a general affine mapping, this does nothing.</li>
<li><em>Product</em>: Because we are dealing with only 3-dimensional mappings here, it
is impossible to use the product because that would give a mapping between
spaces of dimension higher than 3.</li>
</ol>
</div>
<div class="section" id="coordinate-maps">
<h3>Coordinate maps<a class="headerlink" href="#coordinate-maps" title="Permalink to this headline">Â¶</a></h3>
<p>As noted above <em>coordinate maps</em> are equivalent to <em>mappings</em> through the
bijection</p>
<div class="math">
\[((u_D, \mathbb{R}), (u_R, \mathbb{R}), \tilde{f}) \leftrightarrow (D, R, I_R^{-1} \circ \tilde{f} \circ I_D)\]</div>
<p>So, any manipulations on <em>mappings</em>, <em>affine mappings</em> or <em>3-dimensional affine
mappings</em> can be carried out on <em>coordinate maps</em>, <em>affine coordinate maps</em> or
<em>3-dimensional affine coordinate maps</em>.</p>
</div>
</div>
<div class="section" id="implementation">
<h2>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">Â¶</a></h2>
<p>Going from this mathematical description to code is fairly straightforward.</p>
<ol class="arabic">
<li><p class="first">A <em>coordinate system</em> is implemented by the class <em>CoordinateSystem</em> in the
module <a class="reference internal" href="../api/generated/nipy.core.reference.coordinate_system.html#module-nipy.core.reference.coordinate_system" title="nipy.core.reference.coordinate_system"><code class="xref py py-mod docutils literal"><span class="pre">nipy.core.reference.coordinate_system</span></code></a>. Its constructor takes a
list of names, naming the basis vectors of the <em>coordinate system</em> and an
optional built-in numpy scalar dtype such as np.float32.  It has no
interesting methods of any kind. But there is a module level function
<em>product</em> which implements the notion of the product of <em>coordinate systems</em>.</p>
</li>
<li><p class="first">A <em>coordinate map</em> is implemented by the class <em>CoordinateMap</em> in the module
<a class="reference internal" href="../api/generated/nipy.core.reference.coordinate_map.html#module-nipy.core.reference.coordinate_map" title="nipy.core.reference.coordinate_map"><code class="xref py py-mod docutils literal"><span class="pre">nipy.core.reference.coordinate_map</span></code></a>. Its constructor takes two
coordinate has a signature <em>(mapping, input_coords(=domain),
output_coords(=range))</em> along with an optional argument <em>inverse_mapping</em>
specifying the inverse of <em>mapping</em>. This is a slightly different order from
the <span class="math">\((D, R, f)\)</span> order of this document. As noted above, the tuple
<span class="math">\((D, R, f)\)</span> has some redundancy because the function <span class="math">\(f\)</span> must
know its domain, and, implicitly its range.  In <code class="xref py py-mod docutils literal"><span class="pre">numpy</span></code>, it is
impractical to really pass <span class="math">\(f\)</span> to the constructor because <span class="math">\(f\)</span>
would expect something of <em>dtype</em> <span class="math">\(D\)</span> and should return someting of
<em>dtype</em> <span class="math">\(R\)</span>. Therefore, <em>mapping</em> is actually a callable that
represents the function <span class="math">\(\tilde{f} = I_R \circ f \circ I_D^{-1}\)</span>. Of
course, the function <span class="math">\(f\)</span> can be recovered as <span class="math">\(f\)</span> = I_R^{-1} circ
tilde{f} I_D`. In code, <span class="math">\(f\)</span> is roughly equivalent to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nipy.core.api</span> <span class="kn">import</span> <span class="n">CoordinateMap</span><span class="p">,</span> <span class="n">CoordinateSystem</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">in_cs</span> <span class="o">=</span> <span class="n">CoordinateSystem</span><span class="p">(</span><span class="s">&#39;ijk&#39;</span><span class="p">,</span> <span class="s">&#39;voxels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out_cs</span> <span class="o">=</span> <span class="n">CoordinateSystem</span><span class="p">(</span><span class="s">&#39;xyz&#39;</span><span class="p">,</span> <span class="s">&#39;mm&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">map</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coordmap</span> <span class="o">=</span> <span class="n">CoordinateMap</span><span class="p">(</span><span class="n">in_cs</span><span class="p">,</span> <span class="n">out_cs</span><span class="p">,</span> <span class="nb">map</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">domain</span> <span class="o">=</span> <span class="n">coordmap</span><span class="o">.</span><span class="n">function_domain</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">range</span> <span class="o">=</span> <span class="n">coordmap</span><span class="o">.</span><span class="n">function_range</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_tilde</span> <span class="o">=</span> <span class="n">coordmap</span><span class="o">.</span><span class="n">function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">in_dtype</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">coord_dtype</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out_dtype</span> <span class="o">=</span> <span class="nb">range</span><span class="o">.</span><span class="n">dtype</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
<span class="gp">... </span>   <span class="k">return</span> <span class="n">f_tilde</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">in_dtype</span><span class="p">))</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">out_dtype</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ol>
<p>The class <em>CoordinateMap</em> has an <em>inverse</em> property and there are module level
functions called <em>product, compose, linearize</em> and it has methods
<em>reordered_input, reordered_output</em>.</p>
<p>For more detail on the ideas behind the coordmap design, see
<span class="xref std std-ref">coordmp-discussion</span></p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
  <li><a href="../index.html">NIPY home</a> |&nbsp;</li>
 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2005-2013, Neuroimaging in Python team.
      Last updated on Aug 27, 2015.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>